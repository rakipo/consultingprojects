Podcast_neo4j-only_execution_tree.txt

NEO4J PODCAST CONTENT INTELLIGENCE ENGINE - EXECUTION TREE

Purpose: Built for Neo4j freelancer. No Claude runners. No database wrangling. Only focus: ingest from universal Postgres → create a fully queryable, taxonomy-driven knowledge graph that uncovers hidden podcast content opportunities and powers data-driven audio content strategy.

----

BUSINESS CONTEXT: Why This Matters

You're building a podcast content intelligence engine that transforms raw audio content into strategic business insights. This isn't just a database - it's a competitive advantage that reveals patterns humans can't spot manually.

What You're Competing Against:
- Manual episode research that takes hours per topic
- Gut feeling guest selection without audience data backing
- Missing opportunities because you can't see patterns across hundreds of episodes
- Reactive content strategy instead of proactive series planning

What Success Looks Like:
- 10-minute episode research instead of hours of manual analysis
- Data-driven content calendars with proven listener engagement scoring
- Automated competitive podcast analysis that spots gaps before competitors fill them
- Series planning based on actual listener journey mapping and topic relationships

----

INTELLIGENCE GOALS: What The Graph Should Uncover

Pattern Recognition
- Topics with high listener engagement but low episode coverage (untapped opportunities)
- Guest expertise patterns that consistently drive higher engagement
- Content gaps that appear across multiple successful podcasts (validated demand)
- Seasonal patterns in topic performance and audience interest

Strategic Opportunities
- Underexplored topics with high search volume potential in podcast directories
- Series potential based on natural topic progression and listener retention
- Guest collaboration opportunities based on complementary expertise
- Cross-topic opportunities for expanding into adjacent niches

Competitive Intelligence
- Episode frameworks that work across multiple high-performing shows
- Guest selection patterns that drive engagement and downloads
- Topic sequencing that creates binge-worthy series experiences
- Content depth analysis that reveals comprehensive vs surface-level coverage

----

DAILY QUESTIONS: What You'll Query For

Episode Planning (Weekly)
- "What are the top 5 high-urgency gaps in financial planning podcasts with high search potential?"
- "Show me primary topics that have fewer than 3 episodes but high engagement rates"
- "Find content gaps that appear in high-download episodes - these are validated opportunities"

Guest Strategy (Monthly)
- "Which expert domains do successful podcasts feature that I'm completely missing?"
- "What guest expertise combinations work best for complex vs simple topics?"
- "Show me secondary topics that could become series themes based on gap frequency"

Series Development (Quarterly)
- "Map out a 10-episode series starting from 'retirement planning' using natural topic relationships"
- "Find 3 topics that frequently appear together - potential for multi-part series"
- "Which tertiary topics are mentioned enough to warrant dedicated episode coverage?"

Performance Optimization (Ongoing)
- "Show me insights with confidence > 0.8 from high-engagement episodes that I haven't covered yet"
- "Find episode angles that work well for educational vs entertainment formats"
- "Which misconception-type insights get the most listener engagement?"

Audience Intelligence (Strategic)
- "What's the episode progression from awareness → consideration → decision in my niche?"
- "Which topics have high actionability but low episode coverage? (quick wins)"
- "Find episodes where gaps outnumber insights - content that needs follow-up episodes"

----

TECHNICAL REQUIREMENTS FOR FREELANCER

PHASE 0: UNIVERSAL DATABASE INTERFACE (Available)

Input is always this universal PostgreSQL schema — no changes allowed by freelancer.

Table structure (read-only):
- content_items → Universal content metadata (all types including podcast episodes)
- content_insights → Structured insights with confidence
- content_gaps → Gaps/missing knowledge opportunities  
- content_topics → Hierarchy-based topic classifications
- content_hooks → Episode title/description optimization (optional)

Freelancer doesn't touch this — just reads from it.

PHASE 1: BUILD NEO4J GRAPH SCHEMA

This is not just ingestion — it's semantic structuring.

Nodes to Create:
- (:Content) ← content_items table (filtered for content_type = 'podcast_episode')
- (:Insight) ← content_insights table  
- (:Gap) ← content_gaps table
- (:Topic) ← content_topics table
- (:Hook) ← content_hooks table (optional)

Relationships to Establish:

    (:Content)-[:CONTAINS]->(:Insight)
    (:Content)-[:HAS_GAP]->(:Gap)
    (:Content)-[:BELONGS_TO]->(:Topic)  
    (:Content)-[:HAS_HOOK]->(:Hook)

Critical Requirements:
- All merges must use primary keys
- Use MERGE not CREATE to avoid duplicates
- Normalize field types (e.g., confidence as float, hierarchy_level as enum)

PHASE 2: GRAPH TAXONOMY LOGIC

Hierarchies:
- (:Topic) uses:
    - name: "estate_planning"
    - hierarchy_level: "primary", "secondary", "tertiary"
    - audience_intent: "education", "entertainment", "actionable_advice"

Priority Systems:
- Use (:Gap).urgency and (:Insight).confidence for downstream sorting and filtering
- All fields must be queryable in Cypher

PHASE 3: ENABLE CLAUDE-READY QUERIES

Freelancer must validate that the following queries return reliable, performant results:

Sample Queries (must test):

1. High Urgency Episode Gaps:

    MATCH (c:Content)-[:HAS_GAP]->(g:Gap)
    WHERE g.urgency = "high" AND c.content_type = 'podcast_episode'
    RETURN c.title, g.gap_text, c.duration_seconds
    ORDER BY c.publish_date DESC
    LIMIT 10

2. High-Engagement Insights:

    MATCH (c:Content)-[:CONTAINS]->(i:Insight)
    WHERE i.confidence > 0.8 AND c.content_type = 'podcast_episode'
    RETURN c.title, i.text, i.type, c.duration_seconds
    ORDER BY i.confidence DESC

3. Topics Needing Episode Coverage:

    MATCH (c:Content)-[:BELONGS_TO]->(t:Topic), (c)-[:HAS_GAP]->(g:Gap)
    WHERE c.content_type = 'podcast_episode'
    RETURN t.name, count(g) as gap_count, avg(c.duration_seconds) as avg_duration
    ORDER BY gap_count DESC
    LIMIT 5

4. Episode Title Optimization:

    MATCH (c:Content)-[:HAS_HOOK]->(h:Hook)
    WHERE h.estimated_engagement = 'high' AND c.content_type = 'podcast_episode'
    RETURN c.title, h.hook_text, h.category, c.duration_seconds

Freelancer must validate and index anything needed to support these.

5. Series Opportunity Discovery:

    // High-value gaps in popular topics
    MATCH (c:Content)-[:BELONGS_TO]->(t:Topic), (c)-[:HAS_GAP]->(g:Gap)
    WHERE t.hierarchy_level = 'primary' AND g.urgency = 'high' AND c.content_type = 'podcast_episode'
    RETURN t.name, count(g) as gap_count, avg(toInteger(c.engagement_metrics.downloads)) as avg_downloads
    ORDER BY gap_count DESC, avg_downloads DESC

6. Episode Series Strategy:

    // Topics ready for multi-part series
    MATCH (t1:Topic)<-[:BELONGS_TO]-(c:Content)-[:BELONGS_TO]->(t2:Topic)
    WHERE t1 <> t2 AND t1.hierarchy_level = 'primary' AND c.content_type = 'podcast_episode'
    RETURN t1.name, collect(DISTINCT t2.name) as related_topics, count(c) as episode_count, avg(c.duration_seconds) as avg_duration
    HAVING episode_count >= 3

7. Content Intelligence:

    // High-confidence insights not yet exploited
    MATCH (c:Content)-[:CONTAINS]->(i:Insight)
    WHERE i.confidence > 0.8 AND i.actionability = 'high' AND c.content_type = 'podcast_episode'
    RETURN i.text, i.type, count(c) as frequency, avg(c.duration_seconds) as avg_duration
    ORDER BY frequency DESC, i.confidence DESC

8. Episode Format Analysis:

    // Duration patterns for engagement
    MATCH (c:Content)-[:HAS_HOOK]->(h:Hook)
    WHERE h.estimated_engagement = 'high' AND c.content_type = 'podcast_episode'
    RETURN h.psychology_triggers, h.category, count(*) as usage_count, avg(c.duration_seconds) as avg_duration
    ORDER BY usage_count DESC

----

FINAL DELIVERABLES

Freelancer must deliver:
- create_nodes.cypher → node + property schema
- create_relationships.cypher → relationship definitions  
- query_tests.cypher → test suite for key queries
- ingest_runner.py → PostgreSQL → Neo4j data pipeline
- requirements.txt → Python dependencies
- README.md:
    - how ingestion works
    - schema overview  
    - example queries Claude will use
    - indexing strategy if any

----

FINAL TREE OVERVIEW (NEO4J ONLY)

    neo4j_graphrag/
    ├── create_nodes.cypher
    ├── create_relationships.cypher  
    ├── query_tests.cypher
    ├── ingest_runner.py
    ├── requirements.txt
    └── README.md

----

WHY THIS MATTERS TO YOUR BUSINESS

Time Savings: 4-hour episode research → 10-minute queries  
Revenue Impact: Data-driven podcast strategy vs. guesswork  
Competitive Advantage: Spot content opportunities before competitors  
Scale Enabler: Intelligence that grows with your podcast library  

Bottom Line: This graph transforms podcast creation from reactive guesswork into proactive, data-driven audio content strategy.