Social_create_nodes_cypher.txt

create_nodes.cypher

    // Social Media Post Nodes
    MERGE (s:SocialPost {id: $content_id})
    SET s.title = $title,
        s.publish_date = date($publish_date),
        s.content_text = $content_text,
        s.source_url = $source_url,
        s.author_name = $author_name,
        s.content_type = $content_type,
        s.platform = $platform,
        s.character_count = toInteger($character_count),
        s.hashtags = $hashtags,
        s.engagement_metrics = $engagement_metrics;

    // Insight Nodes
    MERGE (i:Insight {id: $insight_id})
    SET i.text = $text,
        i.type = $type,
        i.confidence = toFloat($confidence),
        i.actionability = $actionability,
        i.platform_specific = $platform_specific;

    // Gap Nodes
    MERGE (g:Gap {id: $gap_id})
    SET g.text = $text,
        g.type = $type,
        g.urgency = $urgency,
        g.estimated_content_size = $estimated_content_size,
        g.suggested_title = $suggested_title,
        g.platform_optimization = $platform_optimization,
        g.viral_potential = $viral_potential;

    // Topic Nodes
    MERGE (t:Topic {name: $name})
    SET t.hierarchy_level = $hierarchy_level,
        t.domain = $domain,
        t.audience_intent = $audience_intent,
        t.platform_type = $platform_type,
        t.content_complexity = $content_complexity;

    // Hook Nodes (optional)
    MERGE (h:Hook {id: $hook_id})
    SET h.text = $text,
        h.category = $category,
        h.psychology_triggers = $psychology_triggers,
        h.estimated_engagement = $estimated_engagement,
        h.platform_optimized = $platform_optimized,
        h.character_count = toInteger($character_count);

----

create_relationships.cypher

    // Social Post contains Insight
    MATCH (s:SocialPost {id: $content_id}), (i:Insight {id: $insight_id})
    MERGE (s)-[:CONTAINS]->(i);

    // Social Post has Gap
    MATCH (s:SocialPost {id: $content_id}), (g:Gap {id: $gap_id})
    MERGE (s)-[:HAS_GAP]->(g);

    // Social Post belongs to Topic
    MATCH (s:SocialPost {id: $content_id}), (t:Topic {name: $topic_name})
    MERGE (s)-[:BELONGS_TO]->(t);

    // Social Post has Hook (optional)
    MATCH (s:SocialPost {id: $content_id}), (h:Hook {id: $hook_id})
    MERGE (s)-[:HAS_HOOK]->(h);

----

query_tests.cypher

    // 1. High urgency social content gaps
    MATCH (s:SocialPost)-[:HAS_GAP]->(g:Gap)
    WHERE g.urgency = "high"
    RETURN s.platform, s.title, g.text, g.suggested_title, g.viral_potential
    ORDER BY s.publish_date DESC
    LIMIT 10;

    // 2. High confidence viral insights
    MATCH (s:SocialPost)-[:CONTAINS]->(i:Insight)
    WHERE i.confidence > 0.8 AND i.type = "viral_pattern"
    RETURN s.platform, s.title, i.text, i.actionability
    ORDER BY i.confidence DESC;

    // 3. Platform-specific topic gaps
    MATCH (s:SocialPost)-[:BELONGS_TO]->(t:Topic), (s)-[:HAS_GAP]->(g:Gap)
    WHERE t.hierarchy_level = "primary"
    RETURN s.content_type, t.name, t.platform_type, count(g) as gap_count
    ORDER BY gap_count DESC
    LIMIT 10;

    // 4. Cross-platform engagement insights
    MATCH (s:SocialPost)-[:CONTAINS]->(i:Insight)
    WHERE i.type = "engagement_optimization" AND i.actionability = "high"
    RETURN s.platform, s.content_type, i.text
    ORDER BY i.confidence DESC;

    // 5. Platform-optimized hooks
    MATCH (s:SocialPost)-[:HAS_HOOK]->(h:Hook)
    WHERE h.estimated_engagement = "high"
    RETURN s.platform, h.text, h.psychology_triggers, h.platform_optimized;

    // 6. Viral content opportunities by platform
    MATCH (s:SocialPost)-[:BELONGS_TO]->(t:Topic), (s)-[:HAS_GAP]->(g:Gap)
    WHERE g.viral_potential = "high" AND g.urgency = "high"
    RETURN s.platform, t.name, g.text, g.suggested_title, count(s) as post_count
    ORDER BY post_count ASC;

    // 7. Cross-platform content repurposing
    MATCH (s:SocialPost)-[:CONTAINS]->(i:Insight)
    WHERE i.platform_specific = false
    RETURN s.platform, s.title, i.text, i.type
    ORDER BY i.confidence DESC;

    // 8. Hashtag and engagement analysis
    MATCH (s:SocialPost)
    WHERE s.hashtags IS NOT NULL
    RETURN s.platform, s.hashtags, s.engagement_metrics
    ORDER BY s.engagement_metrics DESC
    LIMIT 10;

    // 9. Professional vs entertainment content gaps
    MATCH (s:SocialPost)-[:BELONGS_TO]->(t:Topic), (s)-[:HAS_GAP]->(g:Gap)
    WHERE t.platform_type IN ["professional", "entertainment"]
    RETURN t.platform_type, t.name, count(g) as gap_count
    ORDER BY gap_count DESC;

----

ingest_runner.py

    from neo4j import GraphDatabase
    import json

    class SocialGraphIngestor:
        def __init__(self, uri, user, password):
            self.driver = GraphDatabase.driver(uri, auth=(user, password))

        def run_query(self, query, parameters):
            with self.driver.session() as session:
                session.run(query, parameters)

        def close(self):
            self.driver.close()

    # Example usage (to be customized by freelancer)
    # ingestor = SocialGraphIngestor("bolt://localhost:7687", "neo4j", "password")
    # ingestor.run_query(NODE_CYPHER_HERE, PARAMS)
    # ingestor.close()

----

requirements.txt

    neo4j==5.17.0

----

README.md

Neo4j Social Media Intelligence Engine

This project enables ingestion from a universal PostgreSQL database into a production-grade Neo4j knowledge graph optimized for social media content intelligence across all platforms (LinkedIn, Twitter, TikTok, Instagram, Facebook).

Setup

1. Install dependencies:
    pip install -r requirements.txt

2. Configure your Neo4j instance and credentials.

3. Use ingest_runner.py with the create_nodes.cypher and create_relationships.cypher files to populate the graph.

Node Types

- (:SocialPost) – Core social media content entity (all platforms)
- (:Insight) – Claude-extracted insights (including viral patterns)
- (:Gap) – Social content opportunities and missing topics
- (:Topic) – Semantic clusters with platform-aware hierarchy
- (:Hook) – Post/caption optimization across platforms

Relationships

- (:SocialPost)-[:CONTAINS]->(:Insight)
- (:SocialPost)-[:HAS_GAP]->(:Gap)
- (:SocialPost)-[:BELONGS_TO]->(:Topic)
- (:SocialPost)-[:HAS_HOOK]->(:Hook) (optional)

Test Queries

See query_tests.cypher for Claude-ready queries, including:
- Platform-specific content gaps
- Viral pattern analysis
- Cross-platform content optimization
- Engagement strategy insights
- Hashtag and audience analysis

Supported Platforms

- LinkedIn (professional content)
- Twitter (real-time engagement)
- TikTok (short-form viral content)
- Instagram (visual storytelling)
- Facebook (community building)

Notes

- All source data must match the universal schema with content_type containing platform identifiers
- This repo is only for Neo4j structure — no Claude runners or PostgreSQL ingestion logic included
- Optimized for cross-platform content strategy and viral content analysis